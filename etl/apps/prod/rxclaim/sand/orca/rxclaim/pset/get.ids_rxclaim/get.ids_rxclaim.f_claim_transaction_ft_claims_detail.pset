!prototype|P|||${AI_PSET}/get.join.files.interim.pset
DRIVER_SOURCE_NAME||||ids_rxclaim.f_claim_transaction
DRIVER_SOURCE_LOGICAL_NAME||||orca_rxclaim
TARGET_NAME||||ids_rxclaim.f_claim_transaction_ft_claims_detail
DRIVER_XFR||||
NON_DRIVER_1_XFR||||
OVERRIDE_JOIN_KEY||||{claim_nbr; claim_seq_nbr; claim_stat_id; src_env_sk}
LOOKUP_FIELDS_KEY||||{}
NON_DRIVER_1_SOURCE_NAME||||ids_rxclaim.ft_claims_detail
NON_DRIVER_1_FILE_TYPE||||IDS
NON_DRIVER_1_OUTPUT_FIELDS||||claim_nbr,claim_seq_nbr,claim_stat_id,adj_rxcount_rxsol_mail_srvc,awp_unit_adjustment,awp_unit_published,drug_category_code,generic_mnftr_cnt,co_insurance_amt,non_prf_drug_patient_pay_amt,brand_prf_patient_pay_amt,cob_carrier_subm_amt,cob_primary_claim_type_ind,cob_primary_payer_id,cob_primary_payer_paid_amt,client_cost_tier_amt,specialty_drug_prg_ind,specialty_drug_prg_mbr_ind,specialty_drug_prg_pharm_ind,adherence_incnt_prg_ind,adherence_incnt_reduction_ind,adherence_incnt_reduction_amt,drug_reserved_elg_ind,drug_reserved_member_elg_ind,plan_sponsor_base_share_amt,plan_sponsor_supl_share_amt,supl_consumer_num,min_copay_amt,consumer_directed_health_ind,specialty_network_prg_ind,ingredient_cost_code,compund_ingredient_comp_cnt,ndc_diff_price_amt,insulin_plan_ind,cob_second_payer_id,cob_second_payer_paid_amt,ncpdp_reject_version_code,low_day_supl_ind,zero_balance_ind,client_mac_id,pharmacy_mac_id,client_contract_dis_fee,tot_publish_awp_amt,clt_awp_discount_rate,app_awp_discount_rate,awp_unit_cost_ind,sbm_dt,sbm_tm,filled_dt,prod_id,src_env_sk,ids_updt_dttm
JOIN_KEY||||{claim_nbr; claim_seq_nbr; claim_stat_id; src_env_sk}
DO_CLEAN||||1
JOIN_TYPE||||Left Outer Join with ICFF Lookup
NON_DRIVER_2_XFR||||
NON_DRIVER_3_XFR||||
OVERRIDE_JOIN_LEVEL_2_KEY||||{claim_nbr; src_env_sk}
OVERRIDE_JOIN_LEVEL_3_KEY||||{prod_id; filled_dt}
DRIVER_PRE_DEDUP_FILTER||||src_env_sk member [vector 480,490]
ENABLE_JOIN_LEVEL_2||||1
NON_DRIVER_2_SOURCE_NAME||||ids_rxclaim.ft_claims_detail.reduced
NON_DRIVER_2_OUTPUT_FIELDS||||claim_nbr,claim_seq_nbr,claim_stat_id,adj_rxcount_rxsol_mail_srvc,awp_unit_adjustment,awp_unit_published,drug_category_code,generic_mnftr_cnt,co_insurance_amt,non_prf_drug_patient_pay_amt,brand_prf_patient_pay_amt,cob_carrier_subm_amt,cob_primary_claim_type_ind,cob_primary_payer_id,cob_primary_payer_paid_amt,client_cost_tier_amt,specialty_drug_prg_ind,specialty_drug_prg_mbr_ind,specialty_drug_prg_pharm_ind,adherence_incnt_prg_ind,adherence_incnt_reduction_ind,adherence_incnt_reduction_amt,drug_reserved_elg_ind,drug_reserved_member_elg_ind,plan_sponsor_base_share_amt,plan_sponsor_supl_share_amt,supl_consumer_num,min_copay_amt,consumer_directed_health_ind,specialty_network_prg_ind,ingredient_cost_code,compund_ingredient_comp_cnt,ndc_diff_price_amt,insulin_plan_ind,cob_second_payer_id,cob_second_payer_paid_amt,ncpdp_reject_version_code,low_day_supl_ind,zero_balance_ind,client_mac_id,pharmacy_mac_id,client_contract_dis_fee,tot_publish_awp_amt,clt_awp_discount_rate,app_awp_discount_rate,awp_unit_cost_ind,sbm_dt,sbm_tm,filled_dt,prod_id,src_env_sk,ids_updt_dttm
ENABLE_JOIN_LEVEL_3||||1
NON_DRIVER_3_SOURCE_NAME||||ids_rxclaim.ft_claims_detail.reduced_1
NON_DRIVER_3_OUTPUT_FIELDS||||claim_nbr,claim_seq_nbr,claim_stat_id,adj_rxcount_rxsol_mail_srvc,awp_unit_adjustment,awp_unit_published,drug_category_code,generic_mnftr_cnt,co_insurance_amt,non_prf_drug_patient_pay_amt,brand_prf_patient_pay_amt,cob_carrier_subm_amt,cob_primary_claim_type_ind,cob_primary_payer_id,cob_primary_payer_paid_amt,client_cost_tier_amt,specialty_drug_prg_ind,specialty_drug_prg_mbr_ind,specialty_drug_prg_pharm_ind,adherence_incnt_prg_ind,adherence_incnt_reduction_ind,adherence_incnt_reduction_amt,drug_reserved_elg_ind,drug_reserved_member_elg_ind,plan_sponsor_base_share_amt,plan_sponsor_supl_share_amt,supl_consumer_num,min_copay_amt,consumer_directed_health_ind,specialty_network_prg_ind,ingredient_cost_code,compund_ingredient_comp_cnt,ndc_diff_price_amt,insulin_plan_ind,cob_second_payer_id,cob_second_payer_paid_amt,ncpdp_reject_version_code,low_day_supl_ind,zero_balance_ind,client_mac_id,pharmacy_mac_id,client_contract_dis_fee,tot_publish_awp_amt,clt_awp_discount_rate,app_awp_discount_rate,awp_unit_cost_ind,sbm_dt,sbm_tm,filled_dt,prod_id,src_env_sk,ids_updt_dttm
JOIN_LEVEL_2_TYPE||||Left Outer Join with ICFF Lookup
JOIN_LEVEL_3_TYPE||||Left Outer Join with ICFF Lookup
JOIN_LEVEL_2_KEY||||{claim_nbr; src_env_sk}
JOIN_LEVEL_3_KEY||||{prod.prod_id; filled_dt}
ADDITIONAL_FIELDS_DML||||record\nstring("\\x01", maximum_length = 1) join_match_ind_1 = "N";\nstring("\\x01", maximum_length = 1) join_match_ind_2 = "N";\nstring("\\x01", maximum_length = 1) join_match_ind_3 = "N";\nend
JOIN_XFR:sandbox||||$[\nbegin\n\nlet join_xfr = if(JOIN_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) \n                 ""\n               else \n                 make_transform("join", [vector make_arg("in0"), make_arg("in1")], [vector make_arg("out")]);\n                 \nlet rfmt_xfr = if(JOIN_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) \n                 make_transform("reformat", [vector make_arg("in")], [vector make_arg("out")])\n               else \n                 "";\n                 \nlet join_key = key_info(JOIN_KEY);\nlet override_join_key = key_info(OVERRIDE_JOIN_KEY);\n\nlet in_vec = for(let key in join_key) : "in." + key.field_name;\n\nlet string("") global_vars = if(JOIN_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) \n"let lookup_identifier_type sec_icff_id = lookup_load('" + NON_DRIVER_1_SEC_FILES_VEC[0] + "', '" + NON_DRIVER_1_SEC_INDEX_VEC[0] + "', 'LKP: DA SEC 1 Template');\nlet bc_lookup_address_type da_address =  allocate_with_defaults();\nlet decimal(\\"\\") match_found =  0;" \n                              else if(JOIN_TYPE member [vector "Left Outer Join with ICFF Lookup", "Inner Join with ICFF Lookup"]) \n'include "~$PUB_DXF_XFR/ids/ids_table_properties.xfr";\ninclude "~$PUB_DXF_XFR/common_functions.xfr";\ninclude "~$PUB_DXF_DML/generic_data_types.dml";\n\nlet lookup_identifier_type current_lookup = lookup_not_loaded(); \nlet string("") datafile = "' + NON_DRIVER_1_FILES_VEC[0] + '";\nlet string("") indexfile=this_partition_path(string_replace(datafile,".dat.gz", ".idx")); \ntype lookup_record_type = ' + read_file(NON_DRIVER_1_FILE_INFO.full_dml_url + "/" + NON_DRIVER_1_FILE_INFO.dml_name) + ';' else "";\n\nif(JOIN_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) begin\n  rfmt_xfr = add_statement(rfmt_xfr, "  if(lookup_match(sec_icff_id, 'LKP: DA SEC 1 Template', " + string_join(in_vec, ",") + ")) begin \n    da_address = lookup_last(sec_icff_id, 'LKP: DA SEC 1 Template', " + string_join(in_vec, ",") + ").prim_da_address;\n    match_found = 1;\n  end\n  else begin\n    da_address = allocate_with_defaults();\n    match_found = 0;\n  end");\n  \n  for(let key in join_key) \n      rfmt_xfr = add_rules(rfmt_xfr, [vector make_rule("out." + key.field_name, "in." + key.field_name, 1)]);\n      \n  for(let field in string_split(NON_DRIVER_1_OUTPUT_FIELDS , ","))\n    if(vector_search(override_join_key, [record field_name field modifiers [vector]], {field_name}) == -1)\n      rfmt_xfr = add_rules(rfmt_xfr, [vector make_rule("out." + field, "allocate_with_defaults()", 1)]);\n      \n  rfmt_xfr = add_rule(rfmt_xfr, "out.da_address", "da_address");\n  rfmt_xfr = add_rule(rfmt_xfr, "out.match_found", "match_found");\n  rfmt_xfr = add_rule(rfmt_xfr, "out.*", "in.*");\nend\nelse if(JOIN_TYPE member [vector "Left Outer Join with ICFF Lookup", "Inner Join with ICFF Lookup"]) begin\n  rfmt_xfr = 'out::reformat(in)=\nbegin \n  let lookup_record_type lookup_record_value = allocate_with_nulls();\n  let lookup_record_type exact_record_value=allocate_with_defaults();\n  let lookup_record_type exact_next_record_value=allocate_with_nulls();\n  \n  let unsigned integer(8) dxf_hk_part1 = in.dxf_hk_part1;\n  let unsigned integer(8) dxf_hk_part2 = in.dxf_hk_part2;\n\n  let decimal("") match_count = 0 ;\n  if (current_lookup == lookup_not_loaded()) \n  current_lookup = lookup_load(this_partition_path(datafile) ,indexfile, "IDS_LKP_TPL"); \n\n  lookup_record_value = if (current_lookup != lookup_not_loaded() ) lookup_last(current_lookup, "IDS_LKP_TPL", dxf_hk_part1) else allocate_with_defaults() ;\n  exact_record_value=allocate_with_defaults();\n  exact_record_value = if (lookup_record_value.dxf_hk_part1 ==0 ) lookup_record_value               // No Match found on half hash key , So this is insert record.\n                      else if  ( dxf_hk_part2 == lookup_record_value.dxf_hk_part2 ) lookup_record_value  //A match is found on dxf part1 as well as dxf part2 keys , this is an exact match in first inetration itself \n                      else                                                                        //A Match is found on half hash key but not on full hash key, find exact match inside iteration  .\n                      begin\n                        match_count=lookup_count(current_lookup, "IDS_LKP_TPL", dxf_hk_part1);\n                          begin block exact_record_match\n                             for (let int k, k < match_count)\n                               begin \n                                exact_next_record_value = if( k == 0 ) lookup_last(current_lookup, "IDS_LKP_TPL", dxf_hk_part1) else lookup_previous(current_lookup,"IDS_LKP_TPL");\n                                 if ( dxf_hk_part2 == exact_next_record_value.dxf_hk_part2 ) \n                                  begin\n                                        exact_record_value = exact_next_record_value;\n                                        exit  exact_record_match;\n                                  end\n                                                                                                 \n                             end\n                          end block exact_record_match\n                       result :: exact_record_value ;\n                       end;\n  out.is_match :: if( exact_record_value.dxf_hk_part1 == 0 and exact_record_value.dxf_hk_part2==0 ) 0 else 1 ;  \n  out.join_match_ind_1 ::  if( exact_record_value.dxf_hk_part1 == 0 and exact_record_value.dxf_hk_part2==0 ) "N" else "Y";\n  out.dxf_hk_part1 :1: in.dxf_hk_part1;\n  out.dxf_hk_part2 :2: in.dxf_hk_part2;\\n' +   \n  string_join(for(let field in string_split(NON_DRIVER_1_OUTPUT_FIELDS , ",")) : \n    if(vector_search(override_join_key, [record field_name field modifiers [vector]], {field_name}) == -1) "  out." + field + " :: exact_record_value." + field, ";\\n")\n  + ';\\n  out.* :4: in.* ;\nend ;';\nend\nelse  begin\n  if(join_key != override_join_key)\n    for(let key in join_key) \n      if(key.field_name != override_join_key[index_of(key)].field_name)\n        join_xfr = add_rules(join_xfr, [vector make_rule("out." + key.field_name, "in0." + key.field_name, 1)\n                                          ,make_rule("out." + key.field_name, "in1." + override_join_key[index_of(key)].field_name, 2)\n                                          ]);\n   \n  join_xfr = add_rules(join_xfr, [vector make_rule("out.*", "in0.*", 1)\n                                          ,make_rule("out.*", "in1.*", 2)\n                                          ]);\nend\n\nresult :: if(JOIN_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF", "Left Outer Join with ICFF Lookup", "Inner Join with ICFF Lookup"]) global_vars + "\\r\\n\\r\\n" + rfmt_xfr \n          else global_vars + "\\r\\n\\r\\n" + join_xfr;\n\nend\n]
JOIN_LEVEL_2_XFR:sandbox||||$[\nbegin\n\nlet join_xfr = if(JOIN_LEVEL_2_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) \n                 ""\n               else \n                 make_transform("join", [vector make_arg("in0"), make_arg("in1")], [vector make_arg("out")]);\n                 \nlet rfmt_xfr = if(JOIN_LEVEL_2_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) \n                 make_transform("reformat", [vector make_arg("in")], [vector make_arg("out")])\n               else \n                 "";\n                 \nlet join_key = key_info(JOIN_LEVEL_2_KEY);\nlet override_join_key = key_info(OVERRIDE_JOIN_LEVEL_2_KEY);\n\nlet in_vec = for(let key in join_key) : "in." + key.field_name;\n\nlet string("") global_vars = if(JOIN_LEVEL_2_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) \n"let lookup_identifier_type sec_icff_id = lookup_load('" + NON_DRIVER_2_SEC_FILES_VEC[0] + "', '" + NON_DRIVER_2_SEC_INDEX_VEC[0] + "', 'LKP: DA SEC 1 Template');\nlet bc_lookup_address_type da_address =  allocate_with_defaults();\nlet decimal(\\"\\") match_found =  0;" \n                              else if(JOIN_LEVEL_2_TYPE member [vector "Left Outer Join with ICFF Lookup", "Inner Join with ICFF Lookup"]) \n'include "~$PUB_DXF_XFR/ids/ids_table_properties.xfr";\ninclude "~$PUB_DXF_XFR/common_functions.xfr";\ninclude "~$PUB_DXF_DML/generic_data_types.dml";\n\nlet lookup_identifier_type current_lookup = lookup_not_loaded(); \nlet string("") datafile = "' + NON_DRIVER_2_FILES_VEC[0] + '";\nlet string("") indexfile=this_partition_path(string_replace(datafile,".dat.gz", ".idx")); \ntype lookup_record_type = ' + read_file(NON_DRIVER_2_FILE_INFO.full_dml_url + "/" + NON_DRIVER_2_FILE_INFO.dml_name) + ';' else "";\n\nif(JOIN_LEVEL_2_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) begin\n  rfmt_xfr = add_statement(rfmt_xfr, "  if(lookup_match(sec_icff_id, 'LKP: DA SEC 1 Template', " + string_join(in_vec, ",") + ")) begin \n    da_address = lookup_last(sec_icff_id, 'LKP: DA SEC 1 Template', " + string_join(in_vec, ",") + ").prim_da_address;\n    match_found = 1;\n  end\n  else begin\n    da_address = allocate_with_defaults();\n    match_found = 0;\n  end");\n  \n  for(let key in join_key) \n      rfmt_xfr = add_rules(rfmt_xfr, [vector make_rule("out." + key.field_name, "in." + key.field_name, 1)]);\n      \n  for(let field in string_split(NON_DRIVER_2_OUTPUT_FIELDS , ","))\n    if(vector_search(override_join_key, [record field_name field modifiers [vector]], {field_name}) == -1)\n      rfmt_xfr = add_rules(rfmt_xfr, [vector make_rule("out." + field, "allocate_with_defaults()", 1)]);\n      \n  rfmt_xfr = add_rule(rfmt_xfr, "out.da_address", "da_address");\n  rfmt_xfr = add_rule(rfmt_xfr, "out.match_found", "match_found");\n  rfmt_xfr = add_rule(rfmt_xfr, "out.*", "in.*");\nend\nelse if(JOIN_LEVEL_2_TYPE member [vector "Left Outer Join with ICFF Lookup", "Inner Join with ICFF Lookup"]) begin\n  rfmt_xfr = 'out::reformat(in)=\nbegin \n  let lookup_record_type lookup_record_value = allocate_with_nulls();\n  let lookup_record_type exact_record_value=allocate_with_defaults();\n  let lookup_record_type exact_next_record_value=allocate_with_nulls();\n  \n  let unsigned integer(8) dxf_hk_part1 = in.dxf_hk_part1;\n  let unsigned integer(8) dxf_hk_part2 = in.dxf_hk_part2;\n\n  let decimal("") match_count = 0 ;\n  if(in.join_match_ind_1 == "N")\n  begin\n  if (current_lookup == lookup_not_loaded()) \n  current_lookup = lookup_load(this_partition_path(datafile) ,indexfile, "IDS_LKP_TPL_LEVEL_2"); \n\n  lookup_record_value = if (current_lookup != lookup_not_loaded() ) lookup_last(current_lookup, "IDS_LKP_TPL_LEVEL_2", dxf_hk_part1) else allocate_with_defaults() ;\n  exact_record_value=allocate_with_defaults();\n  exact_record_value = if (lookup_record_value.dxf_hk_part1 ==0 ) lookup_record_value               // No Match found on half hash key , So this is insert record.\n                      else if  ( dxf_hk_part2 == lookup_record_value.dxf_hk_part2 ) lookup_record_value  //A match is found on dxf part1 as well as dxf part2 keys , this is an exact match in first inetration itself \n                      else                                                                        //A Match is found on half hash key but not on full hash key, find exact match inside iteration  .\n                      begin\n                        match_count=lookup_count(current_lookup, "IDS_LKP_TPL_LEVEL_2", dxf_hk_part1);\n                          begin block exact_record_match\n                             for (let int k, k < match_count)\n                               begin \n                                exact_next_record_value = if( k == 0 ) lookup_last(current_lookup, "IDS_LKP_TPL_LEVEL_2", dxf_hk_part1) else lookup_previous(current_lookup,"IDS_LKP_TPL_LEVEL_2");\n                                 if ( dxf_hk_part2 == exact_next_record_value.dxf_hk_part2 ) \n                                  begin\n                                        exact_record_value = exact_next_record_value;\n                                        exit  exact_record_match;\n                                  end\n                                                                                                 \n                             end\n                          end block exact_record_match\n                       result :: exact_record_value ;\n                       end;\n  end                       \n  out.is_match :: if( exact_record_value.dxf_hk_part1 == 0 and exact_record_value.dxf_hk_part2==0 ) 0 else 1 ;  \n  out.join_match_ind_2 :: if( exact_record_value.dxf_hk_part1 == 0 and exact_record_value.dxf_hk_part2==0 ) "N" else "Y" ;\n  out.dxf_hk_part1 :1: in.dxf_hk_part1;\n  out.dxf_hk_part2 :2: in.dxf_hk_part2;\\n' +   \n  string_join(for(let field in string_split(NON_DRIVER_2_OUTPUT_FIELDS , ",")) : \n    if(vector_search(override_join_key, [record field_name field modifiers [vector]], {field_name}) == -1) "  out." + field + " :: if(in.join_match_ind_1 == 'N') exact_record_value." + field + " else in." + field, ";\\n")\n  + ';\\n  out.* :4: in.* ;\nend ;';\nend\nelse  begin\n  if(join_key != override_join_key)\n    for(let key in join_key) \n      if(key.field_name != override_join_key[index_of(key)].field_name)\n        join_xfr = add_rules(join_xfr, [vector make_rule("out." + key.field_name, "in0." + key.field_name, 1)\n                                          ,make_rule("out." + key.field_name, "in1." + override_join_key[index_of(key)].field_name, 2)\n                                          ]);\n   \n  join_xfr = add_rules(join_xfr, [vector make_rule("out.*", "in0.*", 1)\n                                          ,make_rule("out.*", "in1.*", 2)\n                                          ]);\nend\n\nresult :: if(JOIN_LEVEL_2_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF", "Left Outer Join with ICFF Lookup", "Inner Join with ICFF Lookup"]) global_vars + "\\r\\n\\r\\n" + rfmt_xfr \n          else global_vars + "\\r\\n\\r\\n" + join_xfr;\n\nend\n]
JOIN_LEVEL_3_XFR:sandbox||||$[\nbegin\n\nlet join_xfr = if(JOIN_LEVEL_3_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) \n                 ""\n               else \n                 make_transform("join", [vector make_arg("in0"), make_arg("in1")], [vector make_arg("out")]);\n                 \nlet rfmt_xfr = if(JOIN_LEVEL_3_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) \n                 make_transform("reformat", [vector make_arg("in")], [vector make_arg("out")])\n               else \n                 "";\n                 \nlet join_key = key_info(JOIN_LEVEL_3_KEY);\nlet override_join_key = key_info(OVERRIDE_JOIN_LEVEL_3_KEY);\n\nlet in_vec = for(let key in join_key) : "in." + key.field_name;\n\nlet string("") global_vars = if(JOIN_LEVEL_3_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) \n"let lookup_identifier_type sec_icff_id = lookup_load('" + NON_DRIVER_3_SEC_FILES_VEC[0] + "', '" + NON_DRIVER_3_SEC_INDEX_VEC[0] + "', 'LKP: DA SEC 1 Template');\nlet bc_lookup_address_type da_address =  allocate_with_defaults();\nlet decimal(\\"\\") match_found =  0;" \n                              else if(JOIN_LEVEL_3_TYPE member [vector "Left Outer Join with ICFF Lookup", "Inner Join with ICFF Lookup"]) \n'include "~$PUB_DXF_XFR/ids/ids_table_properties.xfr";\ninclude "~$PUB_DXF_XFR/common_functions.xfr";\ninclude "~$PUB_DXF_DML/generic_data_types.dml";\n\nlet lookup_identifier_type current_lookup = lookup_not_loaded(); \nlet string("") datafile = "' + NON_DRIVER_3_FILES_VEC[0] + '";\nlet string("") indexfile=this_partition_path(string_replace(datafile,".dat.gz", ".idx")); \ntype lookup_record_type = ' + read_file(NON_DRIVER_3_FILE_INFO.full_dml_url + "/" + NON_DRIVER_3_FILE_INFO.dml_name) + ';' else "";\n\nif(JOIN_LEVEL_3_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF"]) begin\n  rfmt_xfr = add_statement(rfmt_xfr, "  if(lookup_match(sec_icff_id, 'LKP: DA SEC 1 Template', " + string_join(in_vec, ",") + ")) begin \n    da_address = lookup_last(sec_icff_id, 'LKP: DA SEC 1 Template', " + string_join(in_vec, ",") + ").prim_da_address;\n    match_found = 1;\n  end\n  else begin\n    da_address = allocate_with_defaults();\n    match_found = 0;\n  end");\n  \n  for(let key in join_key) \n      rfmt_xfr = add_rules(rfmt_xfr, [vector make_rule("out." + key.field_name, "in." + key.field_name, 1)]);\n      \n  for(let field in string_split(NON_DRIVER_3_OUTPUT_FIELDS , ","))\n    if(vector_search(override_join_key, [record field_name field modifiers [vector]], {field_name}) == -1)\n      rfmt_xfr = add_rules(rfmt_xfr, [vector make_rule("out." + field, "allocate_with_defaults()", 1)]);\n      \n  rfmt_xfr = add_rule(rfmt_xfr, "out.da_address", "da_address");\n  rfmt_xfr = add_rule(rfmt_xfr, "out.match_found", "match_found");\n  rfmt_xfr = add_rule(rfmt_xfr, "out.*", "in.*");\nend\nelse if(JOIN_LEVEL_3_TYPE member [vector "Left Outer Join with ICFF Lookup", "Inner Join with ICFF Lookup"]) begin\n  rfmt_xfr = 'out::reformat(in)=\nbegin \n  let lookup_record_type lookup_record_value = allocate_with_nulls();\n  let lookup_record_type exact_record_value=allocate_with_defaults();\n  let lookup_record_type exact_next_record_value=allocate_with_nulls();\n\n  let unsigned integer(8) dxf_hk_part1 = in.dxf_hk_part1;\n  let unsigned integer(8) dxf_hk_part2 = in.dxf_hk_part2;\n\n  let decimal("") match_count = 0 ;\n  if(in.join_match_ind_1 == "N" && in.join_match_ind_2 == "N")\n  begin\n  if (current_lookup == lookup_not_loaded()) \n  current_lookup = lookup_load(this_partition_path(datafile) ,indexfile, "IDS_LKP_TPL_LEVEL_3"); \n\n  lookup_record_value = if (current_lookup != lookup_not_loaded() ) lookup_last(current_lookup, "IDS_LKP_TPL_LEVEL_3", dxf_hk_part1) else allocate_with_defaults() ;\n  exact_record_value=allocate_with_defaults();\n  exact_record_value = if (lookup_record_value.dxf_hk_part1 ==0 ) lookup_record_value               // No Match found on half hash key , So this is insert record.\n                      else if  ( dxf_hk_part2 == lookup_record_value.dxf_hk_part2 ) lookup_record_value  //A match is found on dxf part1 as well as dxf part2 keys , this is an exact match in first inetration itself \n                      else                                                                        //A Match is found on half hash key but not on full hash key, find exact match inside iteration  .\n                      begin\n                        match_count=lookup_count(current_lookup, "IDS_LKP_TPL_LEVEL_3", dxf_hk_part1);\n                          begin block exact_record_match\n                             for (let int k, k < match_count)\n                               begin \n                                exact_next_record_value = if( k == 0 ) lookup_last(current_lookup, "IDS_LKP_TPL_LEVEL_3", dxf_hk_part1) else lookup_previous(current_lookup,"IDS_LKP_TPL_LEVEL_3");\n                                 if ( dxf_hk_part2 == exact_next_record_value.dxf_hk_part2 ) \n                                  begin\n                                        exact_record_value = exact_next_record_value;\n                                        exit  exact_record_match;\n                                  end\n                                                                                                 \n                             end\n                          end block exact_record_match\n                       result :: exact_record_value ;\n                       end;\n  end;                       \n  out.is_match :: if( exact_record_value.dxf_hk_part1 == 0 and exact_record_value.dxf_hk_part2==0 ) 0 else 1 ;  \n  out.join_match_ind_3 :: if( exact_record_value.dxf_hk_part1 == 0 and exact_record_value.dxf_hk_part2==0 ) "N" else "Y" ; \n  out.dxf_hk_part1 :1: in.dxf_hk_part1;\n  out.dxf_hk_part2 :2: in.dxf_hk_part2;\\n' +   \n  string_join(for(let field in string_split(NON_DRIVER_3_OUTPUT_FIELDS , ",")) : \n    if(vector_search(override_join_key, [record field_name field modifiers [vector]], {field_name}) == -1) "  out." + field + " :: if(in.join_match_ind_1 == 'N' && in.join_match_ind_2 == 'N') exact_record_value." + field + " else in." + field, ";\\n")\n  + ';\\n  out.* :4: in.* ;\nend ;';\nend\nelse  begin\n  if(join_key != override_join_key)\n    for(let key in join_key) \n      if(key.field_name != override_join_key[index_of(key)].field_name)\n        join_xfr = add_rules(join_xfr, [vector make_rule("out." + key.field_name, "in0." + key.field_name, 1)\n                                          ,make_rule("out." + key.field_name, "in1." + override_join_key[index_of(key)].field_name, 2)\n                                          ]);\n   \n  join_xfr = add_rules(join_xfr, [vector make_rule("out.*", "in0.*", 1)\n                                          ,make_rule("out.*", "in1.*", 2)\n                                          ]);\nend\n\nresult :: if(JOIN_LEVEL_3_TYPE member [vector "Left Outer Join with ICFF", "Inner Join with ICFF", "Left Outer Join with ICFF Lookup", "Inner Join with ICFF Lookup"]) global_vars + "\\r\\n\\r\\n" + rfmt_xfr \n          else global_vars + "\\r\\n\\r\\n" + join_xfr;\n\nend\n]
