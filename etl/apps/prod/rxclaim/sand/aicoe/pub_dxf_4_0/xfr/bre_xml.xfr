package bre_xml;
/*
This is XML parser for BRE ruleset representation in XMl.
This is not professional grade parser, and it expects all special characters to be escaped.
*/

type XmlDoc_t = 
record 
  xml_element[int] elements;
  xml_attribute[int] attributes;
end;

type XmlAttrsParseInfo_t = 
record
  int gtPos = 0; 
  int[int] ids;
end;

type XmlElemParseInfo_t = 
record
  int startPos = 0;//position in str where this element starts "<", it is relative, in substring passed to parse element fun
  int endPos = 0;//position in str where this element ends ">" 
  int id = 0;//id of this element
end;

// ***************************************************************************************************************************
// GLOBAL STORAGE
// ***************************************************************************************************************************

// building /////////////////////////////////////////////
let xml_id[int] _xml_element_ids = allocate();//used for building, keeps current xml elements ids

//returns current xml element id, or -1 of none
xml_id out :: _get_xml_element_id() =
begin
  let int len = length_of(_xml_element_ids);
  let xml_id id = len>0 ? _xml_element_ids[len-1] : -1;
  out::id;
end;

int out :: _del_xml_element_id() =
begin
  _xml_element_ids = vector_slice(_xml_element_ids,0,length_of(_xml_element_ids)-2);
  out::0;
end;

int out :: _add_xml_element_id(xml_id id) =
begin
  _xml_element_ids = vector_append(_xml_element_ids,id);
  out::0;
end;

//elements //////////////////////////////////////////////
let xml_element[int] _xml_elements = allocate();

//public
xml_element out :: xml_get_element(xml_id id) = 
begin
  out::_xml_elements[id];
end;

//used only in tests
xml_element[int] out :: _xml_get_elements() = 
begin
  out::_xml_elements;
end;

xml_element out :: _xml_add_element(xml_element e) =
begin
  let xml_element ex = e;
  ex.this_element_id = length_of(_xml_elements);
  _xml_elements = vector_append(_xml_elements,ex);
  out::ex;
end;

xml_element out :: _xml_set_element(int id, xml_element e) =
begin
  _xml_elements[id] = e;
  out::e;
end;

//attributes ///////////////////////////////////////////
let xml_attribute[int] _xml_attributes = allocate();

//public
xml_attribute out :: xml_get_attribute(xml_id id) = 
begin
  out::_xml_attributes[id];
end;

//used only in tests
xml_attribute[int] out :: _xml_get_attributes() = 
begin
  out::_xml_attributes;
end;

xml_attribute out :: _xml_add_attribute(xml_attribute a) =
begin
  let xml_attribute ax = a;
  ax.this_attribute_id = length_of(_xml_attributes);
  _xml_attributes = vector_append(_xml_attributes,ax);
  out::ax;
end;

//used only in tests
int out :: _xml_clear() =
begin
  _xml_elements = allocate();
  _xml_attributes = allocate();
  _xml_element_ids = allocate();
  out::0;
end;

// ***************************************************************************************************************************
// UTILITIES
// ***************************************************************************************************************************

//replace '&' first, so call special before optional
dml_metadata_string out :: escape_special_chars(dml_metadata_string in) =
begin
  let dml_metadata_string s = in;
  s = string_replace(s,"&","&amp;");
  s = string_replace(s,"<","&lt;");
  out::s;
end;

dml_metadata_string out :: escape_optional_special_chars(dml_metadata_string in) =
begin
  let dml_metadata_string s = in;
  s = string_replace(s,"'","&apos;");
  s = string_replace(s,'"',"&quot;");
  s = string_replace(s,">","&gt;");
  out::s;
end;

// ***************************************************************************************************************************
// BUILDING
// ***************************************************************************************************************************

//returns id of xml element, adds element to global elements and updates current element ids
xml_id out :: xml_begin_document(dml_metadata_string root_element_type) =
begin
  _xml_clear();
  out::xml_begin_element(root_element_type);
end;

xml_id out :: xml_end_document() = 
begin
  let xml_id id = _get_xml_element_id();
  _del_xml_element_id();
  out::id;
end;

//returns id of newly begun element
xml_id out :: xml_begin_element(dml_metadata_string element_type) = 
begin
  let xml_id id;
  let xml_element e = allocate();
  e.element_type = element_type;
  id = bre_xml_add_element(e);
  _add_xml_element_id(id);
  out::id;
end;

//returns parent id of current element
xml_id out :: xml_end_element() = 
begin
  _del_xml_element_id();
  out::_get_xml_element_id();
end;

xml_id out :: xml_add_attribute(dml_metadata_string name, dml_metadata_string value) = 
begin
  //create new attribute
  let xml_attribute a = allocate();
  a.name = name;
  a.value = value;
  //add to global attributes
  a = _xml_add_attribute(a);
  //update parent element
  begin
    let xml_element e = xml_get_element(_get_xml_element_id());
    let xml_id[int] attributes = is_defined(e.attributes) ? e.attributes : allocate();
    //add to parent attributes
    attributes = vector_append(attributes,a.this_attribute_id);
    //update parent element
    _xml_set_element(
      e.this_element_id,
      [record 
        this_element_id e.this_element_id 
        element_type e.element_type
        n_attributes length_of(attributes) 
        attributes attributes
        n_children e.n_children 
        children e.children
        cdata e.cdata
        ]);
  end;
  out::a.this_attribute_id;
end;

//returns xml_id of the xml element that this cdata got set in
xml_id out :: xml_add_cdata(dml_metadata_string cdata) = 
begin
  let xml_element e = xml_get_element(_get_xml_element_id());
  e.cdata = cdata;
  //update element
  _xml_set_element(e.this_element_id,e); 
  out::e.this_element_id;
end;

//returns xml_id of this element
xml_id out :: bre_xml_add_element(xml_element element) = 
begin
  let xml_element eChild = element;
  //add to global elements
  if(not is_defined(eChild.this_element_id) or eChild.this_element_id<=0)
  begin
    eChild = _xml_add_element(eChild);
  end;
  //update parent, or not if root
  if(_get_xml_element_id()>=0)
  begin
    let xml_element e = xml_get_element(_get_xml_element_id());
    let xml_id[int] elements = is_defined(e.children) ? e.children : allocate();
    //add to parent children
    elements = vector_append(elements,eChild.this_element_id);
    //update parent element
    _xml_set_element(
      e.this_element_id, 
      [record 
        this_element_id e.this_element_id 
        element_type e.element_type
        n_attributes e.n_attributes 
        attributes e.attributes
        n_children length_of(elements) 
        children elements
        cdata e.cdata
        ]);
  end;
  out::eChild.this_element_id;
end;

// ***************************************************************************************************************************
// FORMATTING
// ***************************************************************************************************************************

//no pretty printing
//the cdata is output before child elements
dml_metadata_string out :: xml_format(
  xml_id id = 0, //root id
  int suppress_cdata_if_blank_and_children = 1, //if 1, and cdata has only spaces, tabs, new lines AND if element has child elements, then do not print cdata
  int pretty_print_indent_by_spaces = 0, //0 means do not pretty print
  int suppress_empty_element_closing_tag = 0, //print <bizname/> instead of <bizname></bizname>
  int escape_optional_special_chars = 1,
  int escape_special_chars = 1
  ) = 
begin
  out::_xml_format_recursive(
    id,
    suppress_cdata_if_blank_and_children,
    pretty_print_indent_by_spaces,
    suppress_empty_element_closing_tag,
    escape_optional_special_chars,
    escape_special_chars,
    recursionLevel=0
    );
end;

dml_metadata_string out :: _xml_format_recursive(
  xml_id id, //root id
  int suppress_cdata_if_blank_and_children, //if 1, and cdata has only spaces, tabs, new lines AND if element has child elements, then do not print cdata
  int pretty_print_indent_by_spaces, //0 means do not pretty print
  int suppress_empty_element_closing_tag, //print <bizname/> instead of <bizname></bizname>
  int escape_optional_special_chars,
  int escape_special_chars,
  int recursionLevel //private
  ) = 
begin
  let int spaceCount = pretty_print_indent_by_spaces*recursionLevel;
  let dml_metadata_string xmlstr = "";
  begin
    let xml_element e = xml_get_element(id);
    let int hasChildren = e.n_children>0 and is_defined(e.children);
    let int hasCdata = is_defined(e.cdata) and e.cdata!="";
    let int printClosingTag = hasChildren or not suppress_empty_element_closing_tag or hasCdata;
    //pretty print
    if(pretty_print_indent_by_spaces and recursionLevel>0)
    begin
      xmlstr = xmlstr+"\n"+string_lrepad("",spaceCount," ");
    end;
    //type
    xmlstr = xmlstr+"<"+e.element_type;
    //attributes
    if(e.n_attributes>0 and is_defined(e.attributes))
    begin
      for(let xml_id attrId in e.attributes)
      begin
        let xml_attribute a = xml_get_attribute(attrId);
        let dml_metadata_string value = a.value;
        value = escape_special_chars ? escape_special_chars(value) : value;//replace & first
        value = escape_optional_special_chars ? escape_optional_special_chars(value) : value;
        xmlstr = xmlstr+" "+a.name+"="+'"'+value+'"';
      end;
    end;
    //close opening tag
    if(printClosingTag)
    begin
      xmlstr = xmlstr+">";
    end;
    //cdata
    begin
      let int isBlank = re_replace(e.cdata,"[[:space:]]","")=="";
      if(not isBlank or not hasChildren or not (isBlank and hasChildren and suppress_cdata_if_blank_and_children))
      begin
        let dml_metadata_string cdata = e.cdata;
        cdata = escape_special_chars ? escape_special_chars(cdata) : cdata;//replace & first
        cdata = escape_optional_special_chars ? escape_optional_special_chars(cdata) : cdata;
        xmlstr = xmlstr+cdata;
      end;
    end;
    //child elements
    if(hasChildren)
    begin
      for(let xml_id childId in e.children)
      begin
        let dml_metadata_string childXmlStr = 
          _xml_format_recursive(
            id=childId,
            suppress_cdata_if_blank_and_children=suppress_cdata_if_blank_and_children,
            pretty_print_indent_by_spaces=pretty_print_indent_by_spaces,
            suppress_empty_element_closing_tag=suppress_empty_element_closing_tag,
            escape_optional_special_chars=escape_optional_special_chars,
            escape_special_chars=escape_special_chars,
            recursionLevel=recursionLevel+1
            );
        xmlstr = xmlstr+childXmlStr;
      end;
    end;
    //pretty print ONLY if child elements are present, otherwise print closing tag on the same line
    if(pretty_print_indent_by_spaces and hasChildren)
    begin
      xmlstr = xmlstr+"\n"+string_lrepad("",spaceCount," ");
    end;
    //closing tag
    if(printClosingTag)
      begin
        xmlstr = xmlstr+"</"+e.element_type+">";
      end;
    else
      begin
        //close opening tag (closing tag suppressed)
        xmlstr = xmlstr+"/>";
      end;
  end;
  out::xmlstr;
end;

// ***************************************************************************************************************************
// PARSING
// ***************************************************************************************************************************

xml_element out :: xml_parse(
dml_metadata_string xmlstr
,int add_parent_first = 1//if 1, puts parent xml element before its children in _xml_elements (this is what built in xml_parse does), but it is more efficient in DML to put parrent last
,int unescape_optional_special_chars = 1//if 1, converts &apos; to ' (this is what built in xml_parse does) //optional special character (>, ", ')
,int unescape_special_chars = 1//if 1, converts &amp; to & (this is what built in xml_parse does)
) =
begin
  let xml_element e = allocate();
  _xml_clear();
  if(is_defined(xmlstr) and xmlstr!="")
  begin
    let XmlElemParseInfo_t parseInfo = 
      _xml_parse_element(
        xmlstr
        ,add_parent_first
        ,unescape_optional_special_chars
        ,unescape_special_chars
        ,offset=0
        );
    let int id = parseInfo.id;
    e = xml_get_element(id);
  end; 
  out::e;
end;

//to handle = in attr value, search for first = not preceded by "
//to put " in attr value the value must be delimited by ' e.g. a='"' 
//to put ' in attr value the value must be delimited by " e.g. a="'"
//or ESCAPED e.g. a="&quot;" or a='&apos;' 
//only OPPOSITE quote is allowed in quoted attr value!!! escaping with BACKSLASH DOES NOT WORK!!!
//NOT ALLOWED EXAMPLE: built in xml_parse fails on: compatibility_level=" 1 \" 3 "
//NOT ALLOWED EXAMPLE: built in xml_parse fails on: compatibility_level=' 1 \' 3 '
XmlAttrsParseInfo_t out :: _xml_parse_attributes(dml_metadata_string xmlstr, int gtPos=0, int offset=0) =
begin
  let XmlAttrsParseInfo_t parse = allocate();
  let int[int] ids = allocate();
  let int nextOffset = offset;
  let int nextGtPos = gtPos ? gtPos : string_index(xmlstr,">",offset=nextOffset);
  let int eqPos = string_index(xmlstr,"=",nextOffset);
  while(eqPos and eqPos<nextGtPos)
  begin
    let xml_attribute attribute = allocate();
    let dml_metadata_string name = string_lrtrim(string_substring(xmlstr,nextOffset+1,(eqPos-nextOffset)-1));
    let int doubleQuotePos = string_index(xmlstr,'"',nextOffset);
    let int singleQuotePos = string_index(xmlstr,"'",nextOffset);
    //TODO: assert that at least sq or dq is there
    let int quotePos = doubleQuotePos==0 ? singleQuotePos : (singleQuotePos==0 ? doubleQuotePos : math_min(doubleQuotePos,singleQuotePos));
    let dml_metadata_string quote = string_substring(xmlstr,quotePos,1);
    //let int closingQuotePos = re_index(xmlstr,"[^"+quote+"]*"+quote,offset=quotePos);
    let int closingQuotePos = string_index(xmlstr,quote,offset=quotePos);
    //get attr value
    let int valueStartPos = quotePos+1;
    let int valueEndPos = closingQuotePos-1;
    let int valueStrLen = (valueEndPos-valueStartPos)+1;
    let dml_metadata_string value = string_substring(xmlstr,valueStartPos,valueStrLen);
    //update attr
    //write_to_log_file("/~stdout","name="+string_representation(name)+'\n');
    attribute.name = name;
    attribute.value = value;
    attribute = _xml_add_attribute(attribute);
    ids = vector_append(ids,attribute.this_attribute_id);
    //update open tag closing bracket pos
    if(closingQuotePos>nextGtPos)
    begin
      nextGtPos = string_index(xmlstr,">",offset=closingQuotePos);
    end;
    //find next =
    nextOffset = closingQuotePos;
    eqPos = string_index(xmlstr,"=",nextOffset);
  end;
  parse.ids = ids;
  parse.gtPos = nextGtPos; 
  out::parse;
end;

dml_metadata_string out :: _xml_parse_cdata(dml_metadata_string cdataIn, int unescape_optional_special_chars, int unescape_special_chars) =
begin
  let dml_metadata_string cdata = cdataIn;
  //replace \r\n with \n
  cdata = re_replace(cdata,"\r\n","\n");
  //un-escape optional special chars
  if(unescape_optional_special_chars)
  begin
    cdata = re_replace(cdata,"&apos;","'");
    cdata = re_replace(cdata,"&quot;",'"');
    cdata = re_replace(cdata,"&gt;",">");
  end;
  if(unescape_special_chars)
  begin
    cdata = string_replace(cdata,"&amp;","&");
    cdata = string_replace(cdata,"&lt;","<");
  end;
  out::cdata;
end;

//finds next '<x' (and not '</x')
int out :: _xml_parse_find_open_tag_open_bracket_pos(dml_metadata_string xmlstr, int offset=0) =
begin
  out::re_index(xmlstr,"<[^/]+",offset);
end;

dml_metadata_string out :: _xml_parse_element_type(dml_metadata_string xmlstr, int openTagOpeningBracketPos, int gtPos) =
begin
  let int isCollapsedElement = string_substring(xmlstr,gtPos-1,1)=="/";//<e/> or <e a="1"/>
  let int openTagContentLastPos = gtPos-(isCollapsedElement ? 2 : 1);
  let int firstSpaceAfterOpenTagOpeningBracketPos = re_index(xmlstr,"[[:space:]]",offset=openTagOpeningBracketPos);
  let int elementTypeFirstPos = openTagOpeningBracketPos+1;
  let int elementTypeLastPos = firstSpaceAfterOpenTagOpeningBracketPos ? 
      math_min(firstSpaceAfterOpenTagOpeningBracketPos-1,openTagContentLastPos) : openTagContentLastPos;
  let int elementTypeLen = (elementTypeLastPos-elementTypeFirstPos)+1;
  let dml_metadata_string element_type = string_substring(xmlstr,elementTypeFirstPos,elementTypeLen);
  out::element_type;
end;

/*
returns element's end position in xmlstr
*/
XmlElemParseInfo_t out :: _xml_parse_element(
  dml_metadata_string xmlstr
  ,int add_parent_first//parsing, put xml element parent before its children in _xml_elements (this is what built in xml_parse does), its more efficient in DML to put parrent last
  ,int unescape_optional_special_chars//parsing, converts &apos; to ' (this is what built in xml_parse does) //optional special character (>, ", ')
  ,int unescape_special_chars//parsing, converts &amp; to & (this is what built in xml_parse does)
  ,int offset=0
  ,int nextOpenTagPosIn=0//if >0, then do not look for openTagOpeningBracketPos again, use this instead
  ) =
begin
  //let datetime("HH24:MI:SS.nnnnnn") t1 = now();
  let XmlElemParseInfo_t parseInfo = allocate();
  let int startPos = 0;
  let int endPos = 0;
  let int id = 0;
  if(is_defined(xmlstr) and string_length(xmlstr)>0)
  begin
    //allocate element defaults 
    let xml_element e;//NULL
    let int[int] attributeIds = allocate();
    let int[int] childrenIds = allocate();
    let dml_metadata_string cdata = "";
    let int openTagOpeningBracketPos = nextOpenTagPosIn ? nextOpenTagPosIn : _xml_parse_find_open_tag_open_bracket_pos(xmlstr,offset);
    let int gtPos = string_index(xmlstr,">",offset=openTagOpeningBracketPos);
    //find element type
    let dml_metadata_string element_type = _xml_parse_element_type(xmlstr,openTagOpeningBracketPos,gtPos);
    let int elementTypeLastPos = openTagOpeningBracketPos+string_length(element_type); 
    //parse attributes
    let XmlAttrsParseInfo_t attrsParseInfo = _xml_parse_attributes(xmlstr,gtPos,offset=elementTypeLastPos); 
    let int openTagClosingBracketPos = attrsParseInfo.gtPos;
    let int isCollapsedElement = string_substring(xmlstr,openTagClosingBracketPos-1,1)=="/";//<e/> or <e a="1"/>
    attributeIds = attrsParseInfo.ids;
    //update start position
    startPos = openTagOpeningBracketPos;
    //add parent first if required
    if(add_parent_first)
    begin
      e = allocate();
      e.element_type = element_type;//useful for debugging
      e = _xml_add_element(e);
      id = e.this_element_id;
    end;
    //parse element content (str between open and close tags)
    if(not isCollapsedElement)
      begin
        let dml_metadata_string closeTagStr = "</"+element_type+">";
        let int currentOffset = 0;
        let int hasChildElements = 1;
        let dml_metadata_string remainderStr = string_substring(xmlstr,openTagClosingBracketPos+1,string_length(xmlstr)-openTagClosingBracketPos);
        //is quaranteed to be present, element is not collapsed
        let int closeTagOpeningBracketPos = string_index(remainderStr,closeTagStr,offset=0);
        let dml_metadata_string contentStr = string_prefix(remainderStr,closeTagOpeningBracketPos-1);
        let int hasChildWithSameType = string_index(contentStr,"<"+element_type,offset=0);
        contentStr = hasChildWithSameType ? remainderStr : contentStr;
        //parse child elements
        while(hasChildElements)
        begin
          let int nextOpenTagPos = _xml_parse_find_open_tag_open_bracket_pos(contentStr,offset=currentOffset);
          closeTagOpeningBracketPos = hasChildWithSameType ? string_index(contentStr,closeTagStr,offset=currentOffset) : closeTagOpeningBracketPos;
          hasChildElements = nextOpenTagPos ? nextOpenTagPos<closeTagOpeningBracketPos : 0;
          if(hasChildElements)
            begin
              let XmlElemParseInfo_t parseInfo = 
                _xml_parse_element(
                  contentStr
                  ,add_parent_first
                  ,unescape_optional_special_chars
                  ,unescape_special_chars
                  ,offset=currentOffset
                  ,nextOpenTagPosIn=nextOpenTagPos);
              //debug
              //let dml_metadata_string elemStr = string_substring(contentStr,parseInfo.startPos,(parseInfo.endPos-parseInfo.startPos)+1);
              //prepare cdata, remove from content string all strings corresponding to child elements, preserve formatting
              let int cdataFirstPos = currentOffset+1;
              let int cdataLastPos = parseInfo.startPos-1;
              let int cdataLen = (cdataLastPos-cdataFirstPos)+1;
              cdata = cdata + string_substring(contentStr,cdataFirstPos,cdataLen);
              //update parent element child ids
              childrenIds = vector_append(childrenIds,parseInfo.id);
              //update offset
              currentOffset = parseInfo.endPos;
            end;
        end;
        //recalculate closing tag pos from current offset, this is critical for nested tags with same names
        closeTagOpeningBracketPos = hasChildWithSameType ? string_index(contentStr,closeTagStr,offset=currentOffset) : closeTagOpeningBracketPos;
        begin
          //add rest of cdata, after last elem ended
          let int cdataFirstPos = currentOffset+1;
          let int cdataLastPos = closeTagOpeningBracketPos-1;
          let int cdataLen = (cdataLastPos-cdataFirstPos)+1;
          cdata = cdata + string_substring(contentStr,cdataFirstPos,cdataLen);
          cdata = _xml_parse_cdata(cdata,unescape_optional_special_chars,unescape_special_chars);
          //update end position
          endPos = openTagClosingBracketPos+(closeTagOpeningBracketPos+string_length(closeTagStr))-1;
        end;
      end;
    else
      begin
        endPos = openTagClosingBracketPos;
      end;
    begin
      //let datetime("HH24:MI:SS.nnnnnn") t2 = now();
      //cdata = string_representation(t2);
      //let datetime_difference_type td = datetime_difference(t2,t1);
      //write_to_log_file("/~stdout","s="+string_representation(td.seconds)+" ns="+string_representation(td.microseconds)+" element id="+string_representation(id)+" type="+element_type+"\n");
    end;
    //update element
    e = [record 
      this_element_id id 
      element_type element_type 
      n_attributes length_of(attributeIds) 
      attributes attributeIds 
      n_children length_of(childrenIds) 
      children childrenIds 
      cdata cdata
      ];
    //add to global elements
    if(add_parent_first)
      begin
        _xml_set_element(id, e);
      end;
    else
      begin
        e = _xml_add_element(e);
        id = e.this_element_id;
      end;
    //update parse info
    parseInfo.startPos = startPos;
    parseInfo.endPos = endPos;
    parseInfo.id = id;
  end;
  out::parseInfo;
end;

/*
out :: reformat(in) =
begin
  bre_xml_parse(in.s);
  out.elements::_xml_elements;
  out.attributes::_xml_attributes;
end;
*/
